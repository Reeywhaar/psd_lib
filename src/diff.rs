//! Contains `create_diff` and `apply_diff` functions

use bin_diff::diff::{
	apply_diff as ba_diff, apply_diffblock, combine_diffs as bcombine_diffs,
	combine_diffs_vec as bcombine_diffs_vec,
	combine_diffs_vec_to_diffblocks as bcombine_diffs_vec_to_diffblocks, create_diff as bc_diff,
	measure_diff_size as bc_measure,
};
use bin_diff::indexes::WithIndexes;
use std::io::{BufWriter, Error, ErrorKind, Read, Result as IOResult, Seek, Write};

const PSDDIFF_HEADER: [u8; 10] = [0x50, 0x53, 0x44, 0x44, 0x49, 0x46, 0x46, 0x31, 0x00, 0x01];

/// Measures size of presumed diff
pub fn measure_diff_size<T: WithIndexes, U: WithIndexes>(
	mut original: &mut T,
	mut edited: &mut U,
) -> IOResult<u64> {
	return bc_measure(&mut original, &mut edited).map(|x| x + (PSDDIFF_HEADER.len() as u64));
}

/// creates diff out of two psd files
pub fn create_diff<T: WithIndexes, U: WithIndexes, W: Write>(
	mut original: &mut T,
	mut edited: &mut U,
	output: &mut W,
) -> IOResult<()> {
	let mut stdo = BufWriter::with_capacity(1024 * 64, output);

	stdo.write(&PSDDIFF_HEADER)
		.or(Err(Error::new(ErrorKind::Other, "Cannot write header")))?;

	return bc_diff(&mut original, &mut edited, &mut stdo);
}

/// Combines two diffs
pub fn combine_diffs<T: Read + Seek, U: Read + Seek, W: Write>(
	mut a: T,
	mut b: U,
	mut output: W,
) -> IOResult<()> {
	let mut buf = vec![0; 10];
	{
		(&mut a).take(10).by_ref().read(&mut buf)?;
		if &buf[0..10] != &PSDDIFF_HEADER {
			return Err(Error::new(ErrorKind::Other, "Header mismatch"));
		};
	}
	{
		(&mut b).take(10).by_ref().read(&mut buf)?;
		if &buf[0..10] != &PSDDIFF_HEADER {
			return Err(Error::new(ErrorKind::Other, "Header mismatch"));
		};
	}

	output
		.write(&PSDDIFF_HEADER)
		.or(Err(Error::new(ErrorKind::Other, "Cannot write header")))?;

	return bcombine_diffs(&mut a, &mut b, &mut output);
}

/// Combines multiple diffs
pub fn combine_diffs_vec<T: Read + Seek, W: Write>(
	diffs: &mut Vec<T>,
	mut output: W,
) -> IOResult<()> {
	let mut buf = vec![0; 10];

	for item in diffs.iter_mut() {
		item.take(10).by_ref().read(&mut buf)?;
		if &buf[0..10] != &PSDDIFF_HEADER {
			return Err(Error::new(ErrorKind::Other, "Header mismatch"));
		};
	}

	output
		.write(&PSDDIFF_HEADER)
		.or(Err(Error::new(ErrorKind::Other, "Cannot write header")))?;

	return bcombine_diffs_vec(diffs, &mut output);
}

#[cfg(test)]
mod combine_diff_tests {
	use super::{apply_diff, combine_diffs_vec, create_diff};
	use bin_diff::functions::compute_hash;
	use psd_file::PSDFile;
	use std::fs::File;
	use std::io::{Cursor, Seek, SeekFrom};

	#[test]
	fn works_live_test() {
		#[cfg_attr(rustfmt, rustfmt_skip)]
		let inputs = [
			["b_a.psd", "b_b.psd", "b_c.psd"],
		];

		for files in inputs.iter() {
			let mut files: Vec<_> = files
				.iter()
				.map(|x| {
					let path = format!("./test_data/{}", x);
					let file = File::open(path).unwrap();
					PSDFile::new(file)
				})
				.collect();

			let hash = {
				let index = files.len() - 1;
				compute_hash(&mut files[index])
			};

			let mut diffs = vec![];
			for i in 0..(files.len() - 1) {
				let mut output = Cursor::new(vec![]);
				let (mut chunka, mut chunkb) = files.split_at_mut(i + 1);
				let fa = &mut chunka[chunka.len() - 1];
				let fb = &mut chunkb[0];
				fa.seek(SeekFrom::Start(0)).unwrap();
				fb.seek(SeekFrom::Start(0)).unwrap();
				create_diff(fa, fb, &mut output).unwrap();
				output.seek(SeekFrom::Start(0)).unwrap();
				diffs.push(output);
			}

			let mut combineddiff = {
				let mut diff = Cursor::new(vec![]);
				combine_diffs_vec(&mut diffs, &mut diff).unwrap();
				diff.seek(SeekFrom::Start(0)).unwrap();
				diff
			};

			let restoredhash = {
				let mut original = &mut files[0];
				original.seek(SeekFrom::Start(0)).unwrap();
				let mut output = Cursor::new(vec![]);
				apply_diff(&mut original, &mut combineddiff, &mut output).unwrap();
				output.seek(SeekFrom::Start(0)).unwrap();
				let hash = compute_hash(&mut output);
				hash
			};

			assert_eq!(hash, restoredhash);
		}
	}
}

/// applies diff to psd file
pub fn apply_diff<T: Read, U: Read, W: Write>(
	mut file: &mut T,
	mut diff: &mut U,
	mut output: &mut W,
) -> IOResult<()> {
	let mut buf = vec![0; 10];
	{
		(&mut diff).take(10).by_ref().read(&mut buf)?;
		if &buf[0..10] != &PSDDIFF_HEADER {
			return Err(Error::new(ErrorKind::Other, "Header mismatch"));
		};
	}

	return ba_diff(&mut file, &mut diff, &mut output);
}

#[cfg(test)]
mod apply_diff_tests {
	use super::{apply_diff, create_diff};
	use bin_diff::functions::compute_hash;
	use psd_file::PSDFile;
	use std::fs::File;
	use std::io::{Cursor, Seek, SeekFrom};

	#[test]
	fn works_test() {
		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut file = Cursor::new(vec![
			0xd0, 0x4b, 0x51, 0x00, 0x25, 0xb6, 0x95, 0xf3,
			0xb0, 0xa9, 0x59, 0xdc, 0x30, 0x35, 0x16, 0x7d,
			0x06, 0xa1, 0xf7, 0x66, 0x64, 0x33, 0x05, 0xee,
			0x2b, 0x35, 0xa9, 0x38, 0x80, 0x7f, 0x1c, 0x90,
			0x2c, 0x29, 0x2a, 0x49, 0x79, 0x66, 0x83, 0x55,
			0x8e, 0xce, 0x78, 0xd4, 0xef, 0x0f, 0xaa, 0xaa,
			0x1c, 0x41, 0xaf, 0xa2, 0xed, 0x85, 0xb6, 0x16,
			0x22, 0xe5, 0x83, 0x7a, 0xf7, 0x73, 0x78, 0xf5,
			0xf5, 0x63, 0x3b, 0x0a, 0x6d, 0xe5, 0x0b, 0x36,
			0x4b, 0x97, 0xc2, 0xfe, 0x84, 0x40, 0x3f, 0x74,
			0x20, 0x4b, 0xbb, 0xfe, 0x4c, 0xe1, 0x87, 0xc2,
			0x55, 0x71, 0xa3, 0x87, 0x55, 0xad, 0x87, 0xad,
			0x08, 0x69, 0x39, 0x0f, 0x8d, 0xe2, 0x9a, 0xef,
		]);

		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut diff = Cursor::new(vec![
			0x50, 0x53, 0x44, 0x44, 0x49, 0x46, 0x46, 0x31, // PSDDIFF1
			0x00, 0x01, // version
			0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // skip 16
			0x00, 0x01, 0x00, 0x00, 0x00, 0x20, // add 32
			0xef, 0x22, 0xe4, 0x2c, 0x5f, 0x3c, 0xde, 0x10, //
			0x8d, 0x27, 0x6c, 0xdd, 0xbc, 0xc6, 0xff, 0xf9, //
			0x5c, 0xe1, 0x81, 0x53, 0xda, 0x3b, 0xa6, 0x7e, //
			0xa9, 0xee, 0xe0, 0x00, 0x67, 0x24, 0x25, 0x78, // added 32 data
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // skip 8
			0x00, 0x02, 0x00, 0x00, 0x00, 0x10, // remove 16
			0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // skip 16
			0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, // replace 16 with 32
			0x23, 0x2a, 0xe9, 0x85, 0xfa, 0x6d, 0xb6, 0x78, //
			0xcd, 0x55, 0x66, 0xc2, 0x03, 0x80, 0x33, 0x3d, //
			0xc1, 0x8c, 0x62, 0xfb, 0xbb, 0xde, 0xe2, 0x53, //
			0xc7, 0x41, 0x0e, 0x82, 0xff, 0x60, 0x40, 0xf0, // added 32 data
			0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // skip 32
		]);

		#[cfg_attr(rustfmt, rustfmt_skip)]
		let result = vec![
			0xd0, 0x4b, 0x51, 0x00, 0x25, 0xb6, 0x95, 0xf3, //
			0xb0, 0xa9, 0x59, 0xdc, 0x30, 0x35, 0x16, 0x7d, // skipped
			0xef, 0x22, 0xe4, 0x2c, 0x5f, 0x3c, 0xde, 0x10, //
			0x8d, 0x27, 0x6c, 0xdd, 0xbc, 0xc6, 0xff, 0xf9, //
			0x5c, 0xe1, 0x81, 0x53, 0xda, 0x3b, 0xa6, 0x7e, //
			0xa9, 0xee, 0xe0, 0x00, 0x67, 0x24, 0x25, 0x78, // added
			0x06, 0xa1, 0xf7, 0x66, 0x64, 0x33, 0x05, 0xee, // skipped
			// removed 16
			0x8e, 0xce, 0x78, 0xd4, 0xef, 0x0f, 0xaa, 0xaa, //
			0x1c, 0x41, 0xaf, 0xa2, 0xed, 0x85, 0xb6, 0x16, // skipped 16
			// removed 16 and replaced ->
			0x23, 0x2a, 0xe9, 0x85, 0xfa, 0x6d, 0xb6, 0x78, //
			0xcd, 0x55, 0x66, 0xc2, 0x03, 0x80, 0x33, 0x3d, //
			0xc1, 0x8c, 0x62, 0xfb, 0xbb, 0xde, 0xe2, 0x53, //
			0xc7, 0x41, 0x0e, 0x82, 0xff, 0x60, 0x40, 0xf0, //added 32
			0x4b, 0x97, 0xc2, 0xfe, 0x84, 0x40, 0x3f, 0x74, //
			0x20, 0x4b, 0xbb, 0xfe, 0x4c, 0xe1, 0x87, 0xc2, //
			0x55, 0x71, 0xa3, 0x87, 0x55, 0xad, 0x87, 0xad, //
			0x08, 0x69, 0x39, 0x0f, 0x8d, 0xe2, 0x9a, 0xef, // skipped 32
		];

		let mut output = Cursor::new(vec![0, 136]);
		apply_diff(&mut file, &mut diff, &mut output).unwrap();
		assert_eq!(output.get_ref(), &result);
	}

	#[test]
	fn fails_test() {
		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut file = Cursor::new(vec![
			0xd0, 0x4b, 0x51, 0x00, 0x25, 0xb6, 0x95, 0xf3,
			0xb0, 0xa9, 0x59, 0xdc, 0x30, 0x35, 0x16, 0x7d,
			0x06, 0xa1, 0xf7, 0x66, 0x64, 0x33, 0x05, 0xee,
			0x2b, 0x35, 0xa9, 0x38, 0x80, 0x7f, 0x1c, 0x90,
			0x2c, 0x29, 0x2a, 0x49, 0x79, 0x66, 0x83, 0x55,
			0x8e, 0xce, 0x78, 0xd4, 0xef, 0x0f, 0xaa, 0xaa,
			0x1c, 0x41, 0xaf, 0xa2, 0xed, 0x85, 0xb6, 0x16,
			0x22, 0xe5, 0x83, 0x7a, 0xf7, 0x73, 0x78, 0xf5,
			0xf5, 0x63, 0x3b, 0x0a, 0x6d, 0xe5, 0x0b, 0x36,
			0x4b, 0x97, 0xc2, 0xfe, 0x84, 0x40, 0x3f, 0x74,
			0x20, 0x4b, 0xbb, 0xfe, 0x4c, 0xe1, 0x87, 0xc2,
			0x55, 0x71, 0xa3, 0x87, 0x55, 0xad, 0x87, 0xad,
			0x08, 0x69, 0x39, 0x0f, 0x8d, 0xe2, 0x9a, 0xef,
		]);

		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut diff = Cursor::new(vec![
			0x50, 0x53, 0x44, 0x44, 0x49, 0x46, 0x46, 0x31, // PSDDIFF1
			0x00, 0x01, // version
			0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // skip 16
			0x00, 0x01, 0x00, 0x00, 0x00, 0x20, // add 32
			0xef, 0x22, 0xe4, 0x2c, 0x5f, 0x3c, 0xde, 0x10, //
			0x8d, 0x27, 0x6c, 0xdd, 0xbc, 0xc6, 0xff, 0xf9, //
			0x5c, 0xe1, 0x81, 0x53, 0xda, 0x3b, 0xa6, 0x7e, //
			0xa9, 0xee, 0xe0, 0x00, 0x67, 0x24, 0x25, 0x78, // added 32 data
			0x00, 0x00, 0x00, 0x00, 0x00, 0x08, // skip 8
			0x00, 0x02, 0x00, 0x00, 0x00, 0x10, // remove 16
			0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // skip 16
			0x00, 0x03, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, // replace 16 with 32
			0x23, 0x2a, 0xe9, 0x85, 0xfa, 0x6d, 0xb6, 0x78, //
			0xcd, 0x55, 0x66, 0xc2, 0x03, 0x80, 0x33, 0x3d, //
			0xc1, 0x8c, 0x62, 0xfb, 0xbb, 0xde, 0xe2, 0x53, //
			0xc7, 0x41, 0x0e, 0x82, 0xff, 0x60, 0x40, 0xf0, // added 32 data
			0x00, 0x00, 0x00, 0x00, 0x00, 0x20, // skip 32
		]);

		#[cfg_attr(rustfmt, rustfmt_skip)]
		let result = vec![
			0xd0, 0x4b, 0x51, 0x00, 0x25, 0xb6, 0x95, 0xf3, //
			0xb0, 0xa9, 0x59, 0xdc, 0x30, 0x35, 0x16, 0x7d, // skipped
			0xef, 0x22, 0xe4, 0x2c, 0x5f, 0x3c, 0xde, 0x10, //
			0x8d, 0x27, 0x6c, 0xdd, 0xbc, 0xc6, 0xff, 0xf9, //
			0x5c, 0xe1, 0x81, 0x53, 0xda, 0x3b, 0xa6, 0x7e, //
			0xa9, 0xee, 0xe0, 0x00, 0x67, 0x24, 0x25, 0x78, // added
			0x06, 0xa1, 0xf7, 0x66, 0x64, 0x33, 0x05, 0xee, // skipped
			// removed 16
			0x8e, 0xce, 0x78, 0xd4, 0xef, 0x0f, 0xaa, 0xaa, //
			0x1c, 0x41, 0xaf, 0xa2, 0xed, 0x85, 0xb6, 0x16, // skipped 16
			// removed 16 and replaced ->
			0x23, 0x2a, 0xe9, 0x85, 0xfa, 0x6d, 0xb6, 0x78, //
			0xcd, 0x55, 0x66, 0xc2, 0x03, 0x80, 0x33, 0x3a, // failed line
			0xc1, 0x8c, 0x62, 0xfb, 0xbb, 0xde, 0xe2, 0x53, //
			0xc7, 0x41, 0x0e, 0x82, 0xff, 0x60, 0x40, 0xf0, //added 32
			0x4b, 0x97, 0xc2, 0xfe, 0x84, 0x40, 0x3f, 0x74, //
			0x20, 0x4b, 0xbb, 0xfe, 0x4c, 0xe1, 0x87, 0xc2, //
			0x55, 0x71, 0xa3, 0x87, 0x55, 0xad, 0x87, 0xad, //
			0x08, 0x69, 0x39, 0x0f, 0x8d, 0xe2, 0x9a, 0xef, // skipped 32
		];

		let mut output = Cursor::new(vec![0, 136]);
		apply_diff(&mut file, &mut diff, &mut output).unwrap();
		assert!(output.get_ref() != &result);
	}

	#[test]
	fn header_fail_test() {
		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut file = Cursor::new(vec![
			0xd0, 0x4b, 0x51, 0x00, 0x25, 0xb6, 0x95, 0xf3,
			0xb0, 0xa9, 0x59, 0xdc, 0x30, 0x35, 0x16, 0x7d,
			0x06, 0xa1, 0xf7, 0x66, 0x64, 0x33, 0x05, 0xee,
			0x2b, 0x35, 0xa9, 0x38, 0x80, 0x7f, 0x1c, 0x90,
		]);

		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut diff = Cursor::new(vec![
			0x50, 0x53, 0x44, 0x44, 0x49, 0x46, 0x46, 0x32, // PSDDIFF2
			0x00, 0x01, // version
			0x00, 0x00, 0x00, 0x00, 0x00, 0x10, // skip 16
			0x00, 0x01, 0x00, 0x00, 0x00, 0x20, // add 32
		]);

		let mut output = Cursor::new(vec![0, 136]);
		let res = apply_diff(&mut file, &mut diff, &mut output);
		assert_eq!(res.unwrap_err().to_string(), "Header mismatch".to_string())
	}

	#[test]
	fn action_fail_test() {
		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut file = Cursor::new(vec![
			0xd0, 0x4b, 0x51, 0x00, 0x25, 0xb6, 0x95, 0xf3,
			0xb0, 0xa9, 0x59, 0xdc, 0x30, 0x35, 0x16, 0x7d,
			0x06, 0xa1, 0xf7, 0x66, 0x64, 0x33, 0x05, 0xee,
			0x2b, 0x35, 0xa9, 0x38, 0x80, 0x7f, 0x1c, 0x90,
		]);

		#[cfg_attr(rustfmt, rustfmt_skip)]
		let mut diff = Cursor::new(vec![
			0x50, 0x53, 0x44, 0x44, 0x49, 0x46, 0x46, 0x31, // PSDDIFF2
			0x00, 0x01, // version
			0x4a, 0x00, 0x00, 0x00, 0x00, 0x10, // skip 16
			0x00, 0x01, 0x00, 0x00, 0x00, 0x20, // add 32
		]);

		let mut output = Cursor::new(vec![0, 136]);
		let res = apply_diff(&mut file, &mut diff, &mut output);
		assert_eq!(
			res.unwrap_err().to_string(),
			"Unknown Action: possibly corrupted file or diff".to_string()
		)
	}

	#[test]
	fn works_live_test() {
		#[cfg_attr(rustfmt, rustfmt_skip)]
		let inputs = [
			["a_a.psd", "a_b.psd"],
			["b_a.psd", "b_b.psd"],
			["a_a.psd", "b_b.psd"],
			["a_b.psd", "b_a.psd"],
		];

		for pair in inputs.iter() {
			let pairs = [[pair[0], pair[1]], [pair[1], pair[0]]];
			for pair in pairs.iter() {
				let mut file_a = File::open(format!("./test_data/{}", pair[0])).unwrap();
				let mut file_b = File::open(format!("./test_data/{}", pair[1])).unwrap();

				let hash = compute_hash(&mut file_b);
				file_b.seek(SeekFrom::Start(0)).unwrap();

				let mut file_a = PSDFile::new(file_a);
				let mut file_b = PSDFile::new(file_b);

				let mut diff = Cursor::new(vec![]);
				create_diff(&mut file_a, &mut file_b, &mut diff).unwrap();
				diff.seek(SeekFrom::Start(0)).unwrap();

				file_a.seek(SeekFrom::Start(0)).unwrap();
				let mut restored = Cursor::new(vec![]);
				apply_diff(&mut file_a, &mut diff, &mut restored).unwrap();
				restored.seek(SeekFrom::Start(0)).unwrap();

				let res_hash = compute_hash(&mut restored);

				assert_eq!(hash, res_hash, "pair {:?} failed", pair);
			}
		}
	}
}

/// applies mutiple diffs to psd file
pub fn apply_diffs_vec<T: Read, U: Read + Seek, W: Write>(
	mut file: &mut T,
	mut diffs: &mut Vec<U>,
	mut output: &mut W,
) -> IOResult<()> {
	let mut buf = vec![0; 10];

	for item in diffs.iter_mut() {
		item.take(10).by_ref().read(&mut buf)?;
		if &buf[0..10] != &PSDDIFF_HEADER {
			return Err(Error::new(ErrorKind::Other, "Header mismatch"));
		};
	}

	let mut diffblocks = bcombine_diffs_vec_to_diffblocks(&mut diffs)?;
	for block in diffblocks.iter_mut() {
		apply_diffblock(&mut file, block, &mut output)?;
	}
	return Ok(());
}

#[cfg(test)]
mod apply_diffs_vec_tests {
	use super::{apply_diffs_vec, create_diff};
	use bin_diff::functions::compute_hash;
	use psd_file::PSDFile;
	use std::fs::File;
	use std::io::{Cursor, Seek, SeekFrom};

	#[test]
	fn works_live_test() {
		#[cfg_attr(rustfmt, rustfmt_skip)]
		let inputs = [
			["b_a.psd", "b_b.psd", "b_c.psd"],
		];

		for files in inputs.iter() {
			let mut files: Vec<_> = files
				.iter()
				.map(|x| {
					let path = format!("./test_data/{}", x);
					let file = File::open(path).unwrap();
					PSDFile::new(file)
				})
				.collect();

			let hash = {
				let index = files.len() - 1;
				compute_hash(&mut files[index])
			};

			let mut diffs = vec![];
			for i in 0..(files.len() - 1) {
				let mut output = Cursor::new(vec![]);
				let (mut chunka, mut chunkb) = files.split_at_mut(i + 1);
				let fa = &mut chunka[chunka.len() - 1];
				let fb = &mut chunkb[0];
				fa.seek(SeekFrom::Start(0)).unwrap();
				fb.seek(SeekFrom::Start(0)).unwrap();
				create_diff(fa, fb, &mut output).unwrap();
				output.seek(SeekFrom::Start(0)).unwrap();
				diffs.push(output);
			}

			let restoredhash = {
				let mut original = &mut files[0];
				original.seek(SeekFrom::Start(0)).unwrap();
				let mut output = Cursor::new(vec![]);
				apply_diffs_vec(&mut original, &mut diffs, &mut output).unwrap();
				output.seek(SeekFrom::Start(0)).unwrap();
				let hash = compute_hash(&mut output);
				hash
			};

			assert_eq!(hash, restoredhash);
		}
	}
}
